import textwrap
import hashlib
import hedy
import hedy_translation
import re
import sys
import io
import os
from contextlib import contextmanager
import inspect
import unittest
import utils
from hedy_content import ALL_KEYWORD_LANGUAGES, KEYWORDS

from hedy_sourcemap import SourceRange
from functools import cache


ROOT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


class Snippet:
    def __init__(self, filename, level, code, field_name=None, adventure_name=None, error=None, language=None, key=None, counter=0):
        self.filename = filename
        self.level = level
        self.field_name = field_name if field_name is not None else ''
        self.code = code
        self.error = error
        self.key = key if key is not None else ''
        filename_shorter = os.path.basename(filename)
        if language is None:
            self.language = filename_shorter.split(".")[0]
        else:
            self.language = language
        self.adventure_name = adventure_name
        self.name = f'{self.language}-level{self.level}-{self.key}-{self.field_name}'
        self.hash = sha1digest(self.code)
        self.counter = counter
        if counter > 0:
            self.name += f'-{self.counter + 1}'

    def __repr__(self):
        return f'Snippet({self.name})'


class SkippedMapping:
    """ Class used to test if a certain source mapping contains an exception type """

    def __init__(self, source_range: SourceRange, exception_type: type(Exception)):
        self.source_range = source_range
        self.exception_type = exception_type


@cache
def get_hedy_source_hash():
    directory = os.path.join(ROOT_DIR, 'grammars')

    files_affecting_parsing = (
        [os.path.join(directory, filename) for filename in os.listdir(directory)] +
        [os.path.join(ROOT_DIR, 'hedy.py')]
    )

    files_affecting_parsing.sort()

    files_contents = []
    for filename in files_affecting_parsing:
        with open(filename, 'r', encoding='utf-8', newline='\n') as f:
            contents = f.read()
            files_contents.append(contents)

    all_language_texts = '\n|\n'.join(files_contents)
    return hashlib.sha1(all_language_texts.encode('utf-8')).hexdigest()


class HedyTester(unittest.TestCase):

    level = None
    equality_comparison_with_is = ['is', '=']
    equality_comparison_commands = ['==', '=']
    number_comparison_commands = ['>', '>=', '<', '<=']
    comparison_commands = number_comparison_commands + ['!=']
    arithmetic_operations = ['+', '-', '*', '/']
    quotes = ["'", '"']
    commands_level_4 = [("print 'hello'", "print(f'hello')"),
                        ("name is ask 'who?'", "name = input(f'who?')"),
                        ('name is Harry', "name = 'Harry'")]

    @classmethod
    def setUpClass(cls):
        os.environ["ENABLE_SKIP_FAULTY"] = 'True'  # Always test with skipping faulty enabled

    def snippet_already_tested_with_current_hedy_version(self, snippet, level):
        try:
            hash_language_plus_snippet_and_level = create_hash(get_hedy_source_hash(), snippet, level)
            filename = get_hash_filename(hash_language_plus_snippet_and_level)
            already_successful = os.path.isfile(filename)
            return already_successful
        except UnicodeEncodeError:  # some tests (generated by Hypothesis) can't be hashed
            return False

    @staticmethod
    @contextmanager
    def captured_output():
        new_out, new_err = io.StringIO(), io.StringIO()
        old_out, old_err = sys.stdout, sys.stderr
        try:
            sys.stdout, sys.stderr = new_out, new_err
            yield sys.stdout, sys.stderr
        finally:
            sys.stdout, sys.stderr = old_out, old_err

    @staticmethod
    def run_code(parse_result):
        code = utils.NORMAL_PREFIX_CODE

        if parse_result.has_turtle:
            code += utils.TURTLE_PREFIX_CODE
        if parse_result.has_pygame:
            pygame_test_prefix = (
                'import os\n'
                'os.environ["SDL_VIDEODRIVER"] = "dummy" # No real image drivers exist, set to dummy for testing\n'
                'os.environ["SDL_AUDIODRIVER"] = "disk" # No real audio drivers exist, set to disk for testing\n'
            ) + utils.PYGAME_PREFIX_CODE + (
                "pygame_end = True # Set to True so that we don't get stuck in a loop during testing\n"
            )

            code += pygame_test_prefix

        code += parse_result.code
        # remove sleep comments to make program execution less slow
        code = re.sub(r'time\.sleep\([^\n]*\)', 'pass', code)

        with HedyTester.captured_output() as (out, err):
            exec(code)
        return out.getvalue().strip()

    def name(self):
        return inspect.stack()[1][3]

    def is_not_turtle(self):
        return (lambda result: not result.has_turtle)

    def is_turtle(self):
        return (lambda result: result.has_turtle)

    def result_in(self, list):
        return (lambda result: HedyTester.run_code(result) in list)

    def exception_command(self, command):
        return lambda c: c.exception.arguments['command'] == command

    @staticmethod
    def as_list_of_tuples(*args):
        # used to conver a variable number of paralel list
        # into a list of tuples to be used by the parametrized tester
        # All of the lists need to have the same size
        res = []
        for i in range(len(args[0])):
            t = tuple((item[i] for item in args))
            res.append(t)
        return res

    def codeToInvalidInfo(self, code):
        instance = hedy.IsValid()
        instance.level = self.level
        program_root = hedy.parse_input(code, self.level, 'en')
        is_valid = instance.transform(program_root)
        _, invalid_info = is_valid

        return invalid_info[0].line, invalid_info[0].column

    def multi_level_tester(
            self,
            code,
            max_level=hedy.HEDY_MAX_LEVEL,
            expected=None,
            exception=None,
            skipped_mappings: 'list[SkippedMapping]' = None,
            extra_check_function=None,
            expected_commands=None,
            lang='en',
            translate=True,
            output=None,
            skip_faulty=True
    ):
        # used to test the same code snippet over multiple levels
        # Use exception to check for an exception

        if max_level < self.level:
            raise Exception('Level too low!')

        # ensure we never test levels above the max (useful for debugging)
        max_level = min(max_level, hedy.HEDY_MAX_LEVEL)

        # make it clear in the output this is a multilevel tester
        print('\n\n\n')
        print('-----------------')
        print('Multi-level test!')
        print('\n')

        # Or use expect to check for an expected Python program
        # In the second case, you can also pass an extra function to check
        for level in range(self.level, max_level + 1):
            self.single_level_tester(
                code,
                level,
                expected=expected,
                exception=exception,
                skipped_mappings=skipped_mappings,
                extra_check_function=extra_check_function,
                expected_commands=expected_commands,
                lang=lang,
                translate=translate,
                output=output,
                skip_faulty=skip_faulty)
            print(f'Passed for level {level}')

    def single_level_tester(
            self,
            code,
            level=None,
            exception=None,
            skipped_mappings: 'list[SkippedMapping]' = None,
            expected=None,
            extra_check_function=None,
            output=None,
            expected_commands=None,
            lang='en',
            translate=True,
            skip_faulty=True,
    ):
        if level is None:  # no level set (from the multi-tester)? grap current level from class
            level = self.level
        if self.snippet_already_tested_with_current_hedy_version(code, level):
            return
        else:
            if skipped_mappings is not None:
                result = hedy.transpile(code, level, lang, skip_faulty=skip_faulty)
                for skipped in skipped_mappings:
                    result_error = result.source_map.get_error_from_hedy_source_range(skipped.source_range)
                    self.assertEqual(expected, result.code)
                    self.assertEqual(type(result_error), skipped.exception_type)
                    if extra_check_function is not None:
                        self.assertTrue(extra_check_function(result_error))
            else:
                if exception is not None:
                    with self.assertRaises(exception) as context:
                        result = hedy.transpile(code, level, lang, skip_faulty=skip_faulty)
                    if extra_check_function is not None:
                        self.assertTrue(extra_check_function(context))
                else:
                    result = hedy.transpile(code, level, lang, skip_faulty=skip_faulty)
                    if expected is not None:
                        self.assertEqual(expected, result.code)

                    if translate:
                        if lang == 'en':  # if it is English
                            # and if the code transpiles (evidenced by the fact that we reach this
                            # line) we should be able to translate too

                            # TODO FH Feb 2022: we pick Dutch here not really fair or good practice :D
                            # Maybe we should do a random language?
                            in_dutch = hedy_translation.translate_keywords(
                                code, from_lang=lang, to_lang="nl", level=self.level)
                            back_in_english = hedy_translation.translate_keywords(
                                in_dutch, from_lang="nl", to_lang=lang, level=self.level).strip()
                            self.assert_translated_code_equal(code, back_in_english)
                        else:  # not English? translate to it and back!
                            in_english = hedy_translation.translate_keywords(
                                code, from_lang=lang, to_lang="en", level=self.level)
                            back_in_org = hedy_translation.translate_keywords(
                                in_english, from_lang="en", to_lang=lang, level=self.level)
                            self.assert_translated_code_equal(code, back_in_org)

                    all_commands = result.commands
                    if expected_commands is not None:
                        self.assertEqual(expected_commands, all_commands)
                    # <- use this to run tests locally with unittest
                    if ('ask' not in all_commands) and ('input' not in all_commands) and ('clear' not in all_commands):
                        self.assertTrue(self.validate_Python_code(result))
                    if output is not None:
                        if extra_check_function is None:  # most programs have no turtle so make that the default
                            extra_check_function = self.is_not_turtle()
                        self.assertEqual(output, HedyTester.run_code(result))
                        self.assertTrue(extra_check_function(result))

            # all ok? -> save hash!
            hash_of_run = create_hash(get_hedy_source_hash(), code, level)
            if hash_of_run:
                filename = get_hash_filename(hash_of_run)
                os.makedirs(os.path.dirname(filename), mode=0o777, exist_ok=True)
                with open(filename, "w") as fp:
                    fp.write("")

    def source_map_tester(self, code, expected_source_map: dict):
        result = hedy.transpile(code, self.level, 'en')
        self.assertDictEqual(result.source_map.get_compressed_mapping(), expected_source_map)

    def assert_translated_code_equal(self, orignal, translation):
        # When we translate a program we lose information about the whitespaces of the original program.
        # So when comparing the original and the translated code, we compress multiple whitespaces into one.
        self.assertEqual(re.sub('\\s+', ' ', orignal), re.sub('\\s+', ' ', translation))

    @staticmethod
    def validate_Python_code(parseresult):
        # Code used in the Adventure and Level Defaults tester to validate Hedy code

        try:
            if not parseresult.has_turtle and not parseresult.has_pygame:  # ouput from turtle or pygame cannot be captured
                HedyTester.run_code(parseresult)
        except hedy.exceptions.CodePlaceholdersPresentException:  # Code with blanks is allowed
            pass
        except OSError:
            return True  # programs with ask cannot be tested with output :(
        except Exception:
            return False
        return True

    # The turtle commands get transpiled into big pieces of code that probably will change
    # The followings methods abstract the specifics of the tranpilation and keep tests succinct
    @staticmethod
    def forward_transpiled(val, level):
        return HedyTester.turtle_command_transpiled('forward', val, level)

    @staticmethod
    def turn_transpiled(val, level):
        return HedyTester.turtle_command_transpiled('right', val, level)

    @staticmethod
    def turtle_command_transpiled(command, val, level):
        command_text = 'turn'
        suffix = ''
        if command == 'forward':
            command_text = 'forward'
            suffix = '\n      time.sleep(0.1)'

        type = 'int' if level < 12 else 'float'

        return textwrap.dedent(f"""\
      __trtl = {val}
      try:
        __trtl = {type}(__trtl)
      except ValueError:
        raise Exception(f'While running your program the command <span class="command-highlighted">{command_text}</span> received the value <span class="command-highlighted">{{__trtl}}</span> which is not allowed. Try changing the value to a number.')
      t.{command}(min(600, __trtl) if __trtl > 0 else max(-600, __trtl)){suffix}""")

    @staticmethod
    def sleep_command_transpiled(val):
        return textwrap.dedent(f"""\
        try:
          time.sleep(int({val}))
        except ValueError:
          raise Exception(f'While running your program the command <span class="command-highlighted">sleep</span> received the value <span class="command-highlighted">{{{val}}}</span> which is not allowed. Try changing the value to a number.')""")

    @staticmethod
    def turtle_color_command_transpiled(val):
        return textwrap.dedent(f"""\
      __trtl = f'{val}'
      if __trtl not in ['black', 'blue', 'brown', 'gray', 'green', 'orange', 'pink', 'purple', 'red', 'white', 'yellow']:
        raise Exception(f'While running your program the command <span class="command-highlighted">color</span> received the value <span class="command-highlighted">{{__trtl}}</span> which is not allowed. Try using another color.')
      t.pencolor(__trtl)""")

    @staticmethod
    def input_transpiled(var_name, text):
        return textwrap.dedent(f"""\
    {var_name} = input(f'''{text}''')
    try:
      {var_name} = int({var_name})
    except ValueError:
      try:
        {var_name} = float({var_name})
      except ValueError:
        pass""")

    @staticmethod
    def remove_transpiled(list_name, value):
        return textwrap.dedent(f"""\
      try:
        {list_name}.remove({value})
      except:
        pass""")

    @staticmethod
    def list_access_transpiled(list_access):
        return textwrap.dedent(f"""\
        try:
          {list_access}
        except IndexError:
          raise Exception('catch_index_exception')""")

    # Used to overcome indentation issues when the above code is inserted
    # in test cases which use different indentation style (e.g. 2 or 4 spaces)
    @staticmethod
    def dedent(*args):
        return '\n'.join([textwrap.indent(textwrap.dedent(a[0]), a[1]) if isinstance(a, tuple) else textwrap.dedent(a)
                          for a in args])

    @staticmethod
    def indent(code, spaces_amount=2, skip_first_line=False):
        lines = code.split('\n')

        if not skip_first_line:
            return '\n'.join([' ' * spaces_amount + line for line in lines])
        else:
            return lines[0] + '\n' + '\n'.join([' ' * spaces_amount + line for line in lines[1::]])

    @staticmethod
    def translate_keywords_in_snippets(snippets):
        # fill keyword dict for all keyword languages
        keyword_dict = {}
        for lang in ALL_KEYWORD_LANGUAGES:
            keyword_dict[lang] = KEYWORDS.get(lang)
            for k, v in keyword_dict[lang].items():
                if isinstance(v, str) and "|" in v:
                    # when we have several options, pick the first one as default
                    keyword_dict[lang][k] = v.split('|')[0]
        english_keywords = KEYWORDS.get("en")

        # We replace the code snippet placeholders with actual keywords to the code is valid: {print} -> print
        # NOTE: .format() instead of safe_format() on purpose!
        for snippet in snippets:
            try:
                if snippet[1].language in ALL_KEYWORD_LANGUAGES.keys():
                    snippet[1].code = snippet[1].code.format(**keyword_dict[snippet[1].language])
                else:
                    snippet[1].code = snippet[1].code.format(**english_keywords)
            except KeyError:
                print("This following snippet contains an invalid placeholder...")
                print(snippet)
            except ValueError:
                print("This following snippet contains an unclosed invalid placeholder...")
                print(snippet)

        return snippets


def create_hash(hedy_language, snippet, level):
    try:
        t = snippet + "|\n" + str(level) + "|\n" + hedy_language
        return hashlib.sha1(t.encode('utf-8')).hexdigest()
    except UnicodeEncodeError:  # some tests can't be hashed
        return ''


def get_hash_filename(input_hash):
    # We make one level of subdirectories
    # as some OS'es (Windows) does not like having too many files
    # in one directory.
    # This might be based on very outdated preconceptions, but let's
    # just copy what git does with their hash storage and not think about
    # it too long
    return os.path.join(
        ROOT_DIR,
        ".test-cache",
        input_hash[0:2],
        input_hash,
    )


def sha1digest(x):
    return hashlib.sha1(x.encode('utf-8')).hexdigest()
